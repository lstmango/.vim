<?php

/**
 * 需求跟进
 */
class zbj_service_taskfollow extends zbj_components_baseservice {

	//当前业务ID
	protected $id;
	//当前对象主数据表
	protected $marter_table = 'zbj_model_mk_follow';

	/**
	 * 实例化对象
	 * @param int $id ID
	 */
	public function __construct($id = 0) {
		parent::__construct();
		$this->id = $id;
	}

			
	/**
	 * 重置跟进系统数据,没有则添加
	 * @param	int	$taskid
	 * @param	int	$chance_id
	 * @return bool
	 * */
	public function setFollow($taskid,$chance_id=0){
		$taskid = intval($taskid);
		$chance_id = intval($chance_id);
		
		if($taskid <= 0){
			$this->setError(0,'传入的需求编号错误');
			return false;
		}
		
		$srvTask = new zbj_service_task($taskid);
		$srvTask = $srvTask->init();
		$task = $srvTask->get();
		
		if(empty($task['task_id'])){
			$this->setError(0,'需求不存在');
			return false;
		}
		if(empty($task['manager_id'])){
			$this->setError(0,'需求还未分配交易顾问');
			return false;
		}
		
		$expriestime = $this->_time + (in_array($task['category_id'],array(1448))?1800:3600);
		$expriesymd = date('Y-m-d',$expriestime);
		
		$data = array(
			'expries'	=> $expriesymd,
			'expriestime'	=> $expriestime,
			'dateline'	=> $this->_time,
			'task_id'	=> $taskid,
			'chance_id'	=> $chance_id,
			'level'		=> $this->getFollowLevel($srvTask),
			'issys'		=> 1,
			'giveup_option'	=> 0,
			'giveup_status'	=> 0,
		);

		try{
			$this->_beginTransaction('mk');
			
			// check exsists
			$followlogModel = zbj_model_api::get('zbj_model_mk_followlog');
			$followlog = $followlogModel->selectOne("task_id='{$taskid}'");
			
			if($followlog['level']){
				$data['oldlevel'] = $followlog['level']>0?$followlog['level']:0;
			}
			$follow = $this->model()->selectOne("task_id='{$taskid}'");
			if($follow['follow_id']){
				$this->setId($follow['follow_id']);
			}
            $this->set('allottime', $this->_time);
			$this->set($data);
			if($this->save() === false){
				throw new Exception('保存跟进数据失败');
			}

			if($followlogModel->insert($data) === false){
				throw new Exception('保存跟进日志失败');
			}
			
			$giveupReasonModel = zbj_model_api::get('zbj_model_mk_followgiveupreason');
			$giveupReasonModel->delete("task_id='{$taskid}'");
			
			$cpallotModel = zbj_model_api::get('zbj_model_cp_allot');
			$cpallot = $cpallotModel->selectOne("manager_id='{$task['manager_id']}' and state=1",'config_id');
			if($cpallot['config_id']){
				$srvAllot = new zbj_service_allot($cpallot['config_id']);
				$srvAllot->createlog($taskid,$task['manager_id'],1);
				$srvAllot->processed($taskid);
			}
			
			$this->_commit('mk');
		}catch(Exception $e){
			$this->_rollBack('mk');
			$this->setError(0,$e->getMessage());
			return false;
		}
		return true;
	}
	
			
	/**
	 * 获取跟进等级 //20急、21高、22中、23低
	 * @param	object	$srvTask
	 * @return int
	 * */
	public function getFollowLevel(&$srvTask){
		$task = $srvTask->get();
		
		$taskopisModel = zbj_model_api::get('zbj_model_mk_taskopis');
		$taskopis = $taskopisModel->selectOne(array('task_id'=>$task['task_id']),'ht');
		
		if($taskopis['ht'] == 1) return 20;
		
		$hour = date('H', $task['createtime']);
		
		$weight = 0;//权重
		if($task['amount'] >= 100 && $task['amount'] < 200) {
			$weight = 2;
		}
		if($task['amount']>= 200 && $task['amount'] < 500) {
			$weight = 4;
		}
		if ($task['amount'] >= 500) {
			$weight = 5;
		}
		
		$srvUser = new zbj_service_user($task['user_id']);
		$buyer = $srvUser->get('info.*');
		$score = 0;
		if($buyer['mobile'] || $buyer['tel'] || $buyer['email'] || $buyer['qq']) {
			$point = $task['amount']<=0?0:1;
			$point += ($buyer['mobile'] && $buyer['tel'])?3:1;
			//悬赏非计件
			if ($task['mode'] == 10 && $task['allot'] != 3) {
				$point += 1;
			}
			//logo专场10分
			if ($srvTask->checkSpecialTask() == 18) {
				$point += 10;
			}
			$score = $point * $weight;
		}
		if($score<8){
			$level = 23;
		}else if($score<20){
			$level = 22;
		}else if($score<28){
			$level = ($hour>=23 || $hour<=8)?22:21;
		}else{
			$level = ($hour>=23 || $hour<=8)?22:20;
		}
		return $level;
	}

	/**
	 * 
	 * @param int $manager_id          交易顾问id
	 * @param string $manager_name     交易顾问名
	 * @param int $chance_id           机会id
	 * @param int $task_id             任务id
	 * @param int $dateline            时间
	 * @param int $level               等级
	 * @param date $expries            再次跟进时间
	 * @param text $remark             备注
	 * @param text $reservation_key    预约原因KEY
	 * @param text $reservation_value  预约原因其他
	 * @param text $type               预约类型，1系统自动预约
	 * @param text $detailArray        存放follow_detail表信息，
	 * $detailArray[0]['question']、$detailArray[0]['answer']、$detailArray[0]['option_id']、$detailArray[0]['options']
	 */
	public function add($manager_id, $chance_id = 0, $task_id = 0, $dateline, $level, $expries, $remark = '', $detailArray, $reservation_key, $reservation_value, $type) {
		
		if (!$task_id && !$chance_id) {
			$this->setError(0, "任务编号和机会编号不能同时为空！");
			return false;
		}
		if (!$manager_id && $type != 1) {
			$this->setError(0, "交易顾问id不合法！");
			return false;
		}
		if (!is_array($detailArray) && $type != 1) {
			$this->setError(0, "问题详情格式必须为数组！");
			return false;
		}

		$m_user = new zbj_model_cp_user();
		$user = $m_user->selectOne(array('user_id'=>$manager_id), 'name'); 
		$model = $this->model();
		$m_log = new zbj_model_mk_followlog();
		$m_detail = new zbj_model_mk_followdetail();
		$data['manager_id'] = $manager_id;
		$data['manager_name'] = $type == 1 ? '系统':$user['name'];
		$data['chance_id'] = $chance_id;
		$data['task_id'] = $task_id;
		$data['dateline'] = $dateline;
		$data['oldlevel'] = 0;
		$data['level'] = $level;
		$data['expries'] = $expries;
		$data['expriestime'] = strtotime($expries,time());
		$data['remark'] = $remark;
		$data['issys'] = 0;
		$data['giveup_option'] = 0;
		$data['giveup_status'] = 0;
		$data['giveuptime'] = 0;
		$data['giveupymd'] = "0000-00-00";
		
		if (6 > $level) {
			$data['is_effective_follow'] = 1;
		} 
		
		$followdata=$data;
		$followdata['issend'] = zbj_lib_BaseUtils::getStr($_POST['issend'])?1:0;//是否提醒我
		$followdata['claimtime'] = 0;
		$followdata['is_overtime'] = 0;
		$flag = false; //存放执行成功状态
		//TODO暂时只考虑了task_id的情况，机会id的情况暂时没有处理
		$this->_beginTransaction('mk');
		try {
			$log = $m_log->selectOne(array('task_id'=>$task_id), 'level', null, 'order by log_id desc');
			if ($log) {
				//将该$log的level赋值给oldlevel
				$data['oldlevel'] = $log['level'] > 0 ? $log['level'] : 0;
				//当前等级大于上一个等级，将issea = 0,等级最大的为A
				if ($level < $data['oldlevel']) $data['issea'] = 0;
			}
			if($data['oldlevel']>$data['level']){
				$data['issea']=0;
				$followdata['issea']=0;
			}
			if($log['expriestime']<time()){
				$data['issea']=0;
				$followdata['issea']=0;
			}
			$follow = $model->selectOne(array('task_id'=>$task_id));
			if ($follow) {
				//更新
				if (1 == $follow['issys']) {
					$followdata = $followdata + array('first_follow_date' => date('Y-m-d', $this->_time));
				}
				//第一次有效跟进算着首次跟进（is_first何寻组使用）
				if ((1 == $followdata['is_effective_follow']) && (0 == $follow['is_effective_follow'])) {
					$followdata += array('is_first' => 1);
					//首次有效跟进时间（绩效用）
					$followdata += array('first_effect_follow_time' => $this->_time);
				} else {
					$followdata += array('is_first' => 0);
				}

				if ($model->update(array('task_id'=>$task_id), $followdata)){
					//更新预约附表
				    if($this->reservation($follow,$reservation_key,$reservation_value,$type)){
				    	$flag = true;
				    }else{
                        $flag = false;
						$this->setError(0, "更新跟进附表信息失败");
						throw new Exception("更新跟进附表信息失败");
				    }
				}else {
					$flag = false;
					$this->setError(0, "更新跟进表信息失败");
					throw new Exception("更新跟进表信息失败");
				}
			}else{
				//添加
				if ($model->insert($followdata)){
					$flag = true;
				}else {
					$flag = false;
					$this->setError(0, "添加跟进表信息失败");
					throw new Exception("添加跟进表信息失败");
				}
			}
			if($m_log->insert($data) && $flag){
				$log_id = $m_log->lastInsertId();
				if (!$log_id) {
					$this->setError(0, "添加跟进日志表信息失败");
					throw new Exception("添加跟进日志表信息失败");
				}
				if($type != 1){
					foreach ($detailArray as $k => $v) {
						if (!$m_detail->insert(array('log_id'=>$log_id, 'question'=>$v['question'], 'answer'=>$v['answer'], 'option_id'=>$v['option_id'], 'task_id'=>$task_id, 'chance_id'=>$chance_id, 'options'=>$v['options']))) {
							$this->setError(0, "添加跟进详细表信息失败".var_export($v,true));
							throw new Exception("添加跟进详细表信息失败");
						}
					}
				}
				
				$this->_commit('mk');
				return true;
			}else{
				$this->setError(0, "添加跟进日志表信息失败");
				throw new Exception("添加跟进日志表信息失败");
			}
		} catch (Exception $e) {
			$this->_rollBack('mk');
			return false;
		}
	}

	/**
	 * @abstract 预约数据数组
	 * @param $key预约数组的key
	 */
	private function GetReservationValue($key){
		if($key > 6 || $key <= 0) return false;
		$reservation_key_value = array(
		    1 => '给雇主梳理需求',
		    2 => '查看投标情况',
		    3 => '查看雇主登陆情况,是否及时关注订单',
		    4 => '关注雇主是否有意向服务商',
		    5 => '关注服务商对项目跟进情况',
		    6 => '系统自动建立预约'
		);
		return $reservation_key_value[$key];
	}

    /**
	 * @abstract 预约
	 * @param $reservation跟进数组 $reservation_key预约key $reservation_value预约value
	 */
	private function reservation($reservation,$reservation_key,$reservation_value,$type){
		if((!is_array($reservation_key) || empty($reservation_key)) && (!$reservation_value || is_array($reservation_value)) && $type != 1){
			return $this->setError(0, "传入预约数据有误");
		}

		if(!$reservation['follow_id'] || !$reservation['task_id']) return $this->setError(0, "跟进数据有误");

		$reservation_obj = zbj_model_api::get('zbj_model_mk_followreservationlog');

		//系统自动预约的情况
		if($type == 1){
	        $reservation_key[] = 6;
		}

        $reservation_group = $reservation['reservation_group'];
        $tid = $reservation['task_id'];
        $followid = $reservation['follow_id'];
		$reservation_group = $reservation_group + 1;

		//组装预约条件
		$reservation_sql = "insert into mk_follow_reservationlog (task_id,follow_id,reservation_group,reservation_key,reservation_value,createtime,createymd) VALUES ";
		$createtime = time();
		$createymd = date('Y-m-d',time());

		if(is_array($reservation_key) && !empty($reservation_key)){
			foreach($reservation_key as $k=>$v){
				$reservation_key_sql[] = "({$tid},{$followid},{$reservation_group},{$v},'','{$createtime}','{$createymd}')";
			}
			$reservation_key_res = implode(',',$reservation_key_sql);
			$reservation_key_res = trim($reservation_key_res,',');
			$reservation = $reservation_sql.$reservation_key_res;
		}

		if($reservation_value){
			$reservation_value_res = "({$tid},{$followid},{$reservation_group},0,'{$reservation_value}','{$createtime}','{$createymd}')";
			$reservation = $reservation_sql.$reservation_value_res;
		}

		if($reservation_key_res && $reservation_value_res){
			$reservation = $reservation_sql.$reservation_key_res.','.$reservation_value_res;
		}

		//插入预约数据
		if(!$reservation) $this->setError(0,"无预约数据需要插入！");
		if($reservation_obj->query($reservation) === false) $this->setError(0,"预约数据插入失败");

		//更新follow表reservation_group预约分组
		$reservation_res = $this->model()->update(array('follow_id' => $followid),array('reservation_group' => $reservation_group));
	    if($reservation_res === false) $this->setError(0,"预约失败");

		return true;
	}

	/**
	 * 服务商联系不上雇主，添加跟单小助手数据 20150922
	 * works_id稿件ID task_id任务ID user_id用户ID feedbacktime反馈时间
	 */
	public function addCannotContactData($data){
		try {
			if(!$data['works_id']) {
				$this->setError(0, "稿件ID不能为空");
				throw new Exception("稿件ID不能为空");
			}

			if(!$data['task_id']) {
				$this->setError(0, "任务ID不能为空");
				throw new Exception("任务ID不能为空");
			}

			if(!$data['user_id']) {
				$this->setError(0, "用户ID不能为空");
				throw new Exception("用户ID不能为空");
			}

			if(!$data['feedbacktime']){
				$this->setError(0, "反馈时间不能为空");
				throw new Exception("反馈时间不能为空");
			}

			$data['state'] = $data['state']?$data['state']:0;

			if(!in_array($data['state'],array(0,1))){
				$this->setError(0, "处理状态出错");
				throw new Exception("处理状态出错");
			}
			//var_dump($data);
			//define('DEBUG',1);


			$srvUser = new zbj_service_user($data['user_id']);
			$nickname = $srvUser->get('nickname');

			$this->_beginTransaction('mk');
            
            //服务商联系不上雇主
            $cndata = array(
                  'task_id' => $data['task_id'],
                  'works_id' => $data['works_id'],
                  'user_id' => $data['user_id'],
                  'nickname' => $nickname,
                  'feedbacktime' => $data['feedbacktime'],
                  'feedbackymd' => date('Y-m-d',$data['feedbacktime']),
                  'state' => $data['state'],
            	);
            $createtime = time();
            $createymd = date('Y-m-d',time());

			//未联系到雇主记录表
			$cannotContact = zbj_model_api::get('zbj_model_mk_cannotcontact');
			//未联系到雇主原因
			$cannotContactReason = zbj_model_api::get('zbj_model_mk_cannotcontactreason');

			//查看是否有未联系到雇主记录
			$cannotContactRes = $cannotContact->selectOne(array('works_id' => $data['works_id'],'state' => 0),'cn_id,works_id');
			var_dump($cannotContactRes);
			if($cannotContactRes){
				//如果有数据则更新
				$cn_id = $cannotContact->update(array('works_id' => $data['works_id'],'state' => 0),$cndata);
				$cnid = $cannotContactRes['cn_id'];
				$condition = array('cn_id' => $cannotContactRes['cn_id']);
			}else{
				//如果没数据则插入
				$cn_id = $cannotContact->insert($cndata);
				var_dump($cannotContact);
				var_dump($cn_id);
				$cnid = $cn_id;
				$condition = array('cn_id' => $cn_id);
			}

			if($cn_id === false){
				$this->setError(0, "未联系到雇主记录保存失败");
			    throw new Exception("未联系到雇主记录保存失败");
			}

			//服务商联系不上雇主原因
            if(!empty($data['reason'])){
            	$rssql = "insert into mk_cannot_contact_reason (cn_id,reason_key,reason_value,createtime,createymd) values";
            	foreach($data['reason'] as $k=>$v){
            		if($k == 0){
                       //其他
                       $sql[] = "($cnid,0,'{$v}',$createtime,$createymd)";
            		}else{
                       $sql[] = "($cnid,$v,'',$createtime,$createymd)";
            		}
            	}
            	$sqlstr = implode(',',$sql);
            	$sqlstr = trim($sqlstr,',');
            	$rssql = $rssql.$sqlstr;

				var_dump($rssql);
            	$cannotContactReasonRes = $cannotContactReason->selectOne($condition,'cn_id');
				if($cannotContactReasonRes){
					$cannotContactReason->delete($condition);
				}

				$res = $cannotContactReason->query($rssql);
				if($res === false){
					$this->setError(0, "服务商联系不上雇主原因保存失败");
			        throw new Exception("服务商联系不上雇主原因保存失败");
				}
            }

			$this->_commit('mk');
			return true;
		} catch (Exception $e) {
			$this->_rollBack('mk');
			return false;
		}
	}

    /**
	 * 获取交易顾问的协助列表 20150922
	 * adviser交易顾问ID state 0未处理 1已处理 createTimeStart createTimeEnd 筛选时间段 offset rows 数据段
	 */
	public function getManagerAssistList($data){
		if(!$data['adviser']) {
			$this->setError(0, "稿件ID不能为空");
			return false;
		}

		if(!in_array($data['state'],array(0,1))) {
			$this->setError(0, "处理状态出错");
			return false;
		}

        $data['appid']='trade';
		$data['service']='AssistService';
		$data['method']='getAssistForAdviser';
		$dataArray['data'] = array(
              'adviser' => $data['adviser'],
              'state' => $data['state'],
              'createTimeStart' => $data['createTimeStart'],
              'createTimeEnd' => $data['createTimeEnd'],
              'offset' => $data['offset'],
              'rows' => $data['rows']
			);
		$jsonData = json_encode($dataArray,true);
		$data['param'] = $jsonData;
		$res = new zbj_lib_ApiHttpClient($data);
		$res = $res->execute();
        return $res;
	}

	/**
	 * 对协助数据回复 20150922
	 * recordId,回复哪一条协助数据
     * userId，回复填写人的id
     * userRole,回复填写人的角色1:雇主，2:服务商，3:交易顾问
     * replyContent，回复的内容
     * 返回{"success":true}
	 */
	public function assistInDataRecovery($data){
		if(!$data['recordId']) {
			$this->setError(0, "协助记录ID不能为空");
			return false;
		}

		if(!$data['userId']) {
			$this->setError(0, "用户ID不能为空");
			return false;
		}

		if(!$data['userRole']) {
			$this->setError(0, "用户角色不能为空");
			return false;
		}

        $data['appid']='trade';
		$data['service']='AssistService';
		$data['method']='reply';
		$dataArray['data'] = array(
			  'terminal' => $data['terminal'],
              'recordId' => $data['recordId'],
              'userId' => $data['userId'],
              'userRole' => $data['userRole'],
              'replyContent' => $data['replyContent']
			);
		$jsonData = json_encode($dataArray,true);
		$data['param'] = $jsonData;
		$res = new zbj_lib_ApiHttpClient($data);
		$res = $res->execute();
        return $res;
	}
	
	/**
	 * 获取跟单小助手数据 20150922
	 * taskId 任务ID worksId稿件ID userId 回复填写人的id  userRole,回复填写人的角色1:雇主，2:服务商，3:交易顾问 offset rows 数据段
	 */
	public function getAssistData($data){
        $data['appid']='trade';
		$data['service']='SecretaryService';
		$data['method']='getSecretaryList';
		$dataArray['data'] = array(
              'taskId' => $data['taskId'],
              'worksId' => $data['worksId'],
              'userId' => $data['userId'],
              'userRole' => $data['userRole'],
              'offset' => $data['offset'],
              'rows' => $data['rows']
			);
		$jsonData = json_encode($dataArray,true);
		$data['param'] = $jsonData;
		$res = new zbj_lib_ApiHttpClient($data);
		$res = $res->execute();
        return $res;
	}

	/**
	 * 标记协助为已处理 20150922
	 * recordId协助数据ID  state 1标记为已处理
	 */
	public function markAssistance($data){
		if(!$data['recordId']) {
			$this->setError(0, "协助记录ID不能为空");
			return false;
		}

        $data['appid']='trade';
		$data['service']='AssistService';
		$data['method']='markDeal';
		$dataArray['data'] = array(
              'recordId' => $data['recordId'],
              'state' => $data['state']
			);
		$jsonData = json_encode($dataArray,true);
		$data['param'] = $jsonData;
		$res = new zbj_lib_ApiHttpClient($data);
		$res = $res->execute();
        return $res;
	}

	
}
