<?php
/**
 * 订单分配系统待分配任务池子
 * @author lidacheng
 * @update lstmango
 */
class zbj_service_allot_taskpool extends zbj_components_baseservice {
	
	protected $id;
	protected $marter_table = 'zbj_model_mk_allotpool';
	private $startWeights=0;
	
	/**
	 * 构造函数
	 */
	public function __construct($id=0) {
		parent::__construct();
		$this->id = $id;
	}
	
	/**
	 * 将需求加入待分配池子
	 * @param	object	$srvTask
	 * @return bool
	 * @author lidacheng
	 * */
	public function pushToAllotPool(&$srvTask){
		if(empty($srvTask) || !is_object($srvTask)){ 
			$this->setError(0,'传递的需求对象异常');
			return false;
		}
		
		$task = $srvTask->get();
		if(empty($task['task_id'])){
			$this->setError(0,'需求不存在');
			return false;
		}
		
		if($task['open_state']!=0 || $task['manager_id']!=0){
			$this->setError(0,'需求已关闭或已分配交易顾问');
			return false;
		}
		// 不需分配
		$srvAlloter = new zbj_service_allot_taskallot();
		$dimensions = $srvAlloter->checkTaskNeedAllot($srvTask,false);
		if(!is_array($dimensions) || $dimensions[0]['dimension_id']<=0){
			$this->setError(0,'不符合分配维度');
			return true;
		}
		$config = $dimensions[0]['config'];
		$delaytime = $config['allot_type']==378?intval($config['extend']):0; // 延迟分钟
		$delaytime <= 0 && $delaytime = 0;
		
		$basechktime = $this->_time+5+($delaytime*60); // 秒
		
		$prestr = '添加到';
		$srvAllotLog = new zbj_service_taskallotlog();
		
		try{
			$this->_beginTransaction('mk');
			
			$srvTask->set('isaudit',-1); // 池子标识
			if($srvTask->save() === false){
				throw new Exception('更新待分配标识失败');
			}
			
			$weights=$this->_get_task_weights($task);
			$data = array(
				'needallot'	=> 1,
				'allotstate'	=> 0,
				'allottime'		=> 0,
				'type'		=> 1,
				'weights'		=> $this->startWeights+$weights,
			);
			
			$poolCondition = array(
				'task_id'	=> $task['task_id'],
				'type'		=> 1,
			);
			$allotPoolModule = zbj_model_api::get('zbj_model_mk_allotpool');
			$taskpool=$allotPoolModule->selectOne($poolCondition);
			
			//添加
			if(empty($taskpool['task_id'])){
				$data['task_id'] = $task['task_id'];
				$data['createtime'] = $this->_time;
				$data['next_chktime']	= $basechktime;
				$data['begin_chktime']	= $basechktime;
				$updatePoolResult = $allotPoolModule->insert($data);
			}else{
				$prestr = '更新';
				if($task['amount']<=0){
					if($taskpool['next_chktime']<$this->_time){
						$data['next_chktime']	= $basechktime+120; // 0元需求延迟2分钟
						$data['begin_chktime']	= $basechktime;
					}
				}else{
					$data['next_chktime']	= $basechktime; 
					$data['begin_chktime']	= $basechktime;
				}
				$taskAllotGrabModule = zbj_model_api::get('zbj_model_mk_taskallotgrab');
				$taskAllotGrabArray=$taskAllotGrabModule->selectOne($poolCondition);
				if($taskAllotGrabArray){
					throw new Exception($prestr.'待分配池子失败2');
				}
				$allotGrabPoolModule = zbj_model_api::get('zbj_model_mk_allotgrabpool');
				$allotGrabArray=$allotGrabPoolModule->selectOne($poolCondition);
				if($allotGrabArray){
					$delResult=$allotGrabPoolModule->delete($poolCondition);
					if(!$delResult){
						throw new Exception($prestr.'待分配池子失败3');
					}
				}
				$updatePoolResult = $allotPoolModule->update($poolCondition,$data);
			}
			if(!$updatePoolResult){
				throw new Exception($prestr.'待分配池子失败');
			}
			
			$this->_commit('mk');
		}catch(Exception $e){
			$this->_rollBack('mk');
			$this->setError(0,$e->getMessage());
			$srvAllotLog->addTaskAllotLog($task['task_id'],array($e->getMessage()));
			return false;
		}
		
		$srvAllotLog->addTaskAllotLog($task['task_id'],array($prestr.'待分配池子成功'));
		return true;
	}
	
	/*
	 *获取任务权重值
	 */
	private function _get_task_weights($task){
		if($task['mode']==10 && $task['allot']==3){
			$weights=20;
		}
		elseif($task['mode']==11 || $task['mode']==12){
			$weights=30;
		}
		elseif($task['mode']==10 && $task['allot']!=3){
			$weights=40;
		}
		elseif($task['mode']==13){
			$weights=60;
		}
		else{
			$weights=20;
		}
		return $weights;
	}
	
	/**
	 * 将需求从待分配池子里释放出来，不需进行分配
	 * @param	object	$srvTask
	 * @param	string	$reason
	 * @return bool
	 * @author lidacheng
	 * */
	public function releaseFromAllotPool(&$srvTask,$reason=''){
		if(empty($srvTask) || !is_object($srvTask)){
			$this->setError(0,'传递的参数错误');
			return false;
		}
		
		$task = $srvTask->get();
		if(empty($task['task_id'])){
			$this->setError(0,'需求不存在');
			return false;
		}
		
		$srvAllotLog = new zbj_service_taskallotlog();
		
		try{
			$this->_beginTransaction('mk');
			$poolCondition = array(
				'task_id'	=> $task['task_id'],
				'type'		=> 1,
			);
			$uppool = array(
				'allotstate'	=> 0,
				'needallot'		=> 0,
			);
			
			$allotPoolModule = zbj_model_api::get('zbj_model_mk_allotpool');
			$poolSaveResult = $allotPoolModule->update($poolCondition,$uppool);
			
			if(!$poolSaveResult){
				throw new Exception('从待分配池子释放需求失败');
			}
			
			$this->_commit('mk');
		}catch(Exception $e){
			$this->_rollBack('mk');
			$this->setError(0,$e->getMessage());
			$srvAllotLog->addTaskAllotLog($task['task_id'],array($e->getMessage()));
			return false;
		}
		
		$srvAllotLog->addTaskAllotLog($task['task_id'],array('已从池子释放'.$reason));
		
		return true;
	}
	
	
	/**
	 * 分配失败，将需求重新放入池子
	 * 		如果是晚上的需求，会直接放入到第二天的延迟分配池子当中
	 * @param	object		$srvTask
	 * @param	bool		$isdelay	是否延迟系统调用
	 * @return	bool
	 * */
	public function repushToAllotPool(&$srvTask,$isdelay=false){
		if(empty($srvTask) || !is_object($srvTask)){
			$this->setError(0,'传递的参数错误');
			return false;
		}
		
		$task = $srvTask->get();
		if(empty($task['task_id'])){
			$this->setError(0,'需求不存在');
			return false;
		}
		
		$nowhour = date('H',time());
		$nowdate = date('Y-m-d');
		
		$srvAllotLog = new zbj_service_taskallotlog();
		
		try{
			$this->_beginTransaction('mk');
			
			$poolCondition = array(
				'task_id'	=> $task['task_id'],
				'type'		=> 1,
			);
			$allotPoolModule = zbj_model_api::get('zbj_model_mk_allotpool');
			$taskpool=$allotPoolModule->selectOne($poolCondition);
			if(empty($taskpool['task_id'])){
				throw new Exception('在待分配池子内没有找到该需求');
			}
			
			if($isdelay){ // 延迟系统调用，重置参数
				$isaudit = -1;
				$updata = array(
					'needallot'		=> 1,
					'allotstate'	=> 0,
					'next_chktime'		=> $this->_time+5,
					'begin_chktime'		=> $this->_time+5,
				);
			#2015-09-29由晚上11点改为晚上10点
			}else if( ($nowhour >= 22 && $nowdate==$task['createymd']) || ($nowhour<9 && $nowdate==date('Y-m-d',(strtotime($task['createymd'])+86400)) )){
				$isaudit = -2; // 无人上班的时间段，直接进第二天的延迟分配池子
				$updata = array(
					'needallot'		=> 0,
					'allotstate'	=> 0,
					'next_chktime'		=> 0,
					'begin_chktime'		=> 0,
				);
			}else if($taskpool['next_chktime']-$taskpool['begin_chktime']>600){ // 已在池子中超过10分钟
				#2015-09-29由晚上8点改为晚上10点
				if( ($nowhour >= 22 && $nowdate==$task['createymd']) || ($nowhour<9 && $nowdate==date('Y-m-d',(strtotime($task['createymd'])+86400)) )){
					$isaudit = -2; // 进第二天的延迟分配池子
					$updata = array(
						'needallot'		=> 0,
						'allotstate'	=> 0,
						'next_chktime'		=> 0,
						'begin_chktime'		=> 0,
					);
				}else{	#改为盲抢	2015-9-7
					$isaudit = 1;
					$updata = array(
						'needallot'		=> 2,//盲抢
						'allotstate'	=> 0,
						'next_chktime'		=> $this->_time,
					);
				}
				/*
				 *}else{	// 完全释放，交给审核
				 *    $isaudit = 1;
				 *    $updata = array('allotstate' => 2);
				 *}
				 */
				
			}else{ // 正常延迟
				$isaudit = -1;
				$updata = array(
					'allotstate'	=> 0, // 分配失败，标识为0后正常重试
					'next_chktime' 	=> $this->_time+120,
				);
			}

			//判断需求是否为商机需求且为重要或紧急
			if($srvTask->isBusinessImportant()){
				$isaudit = -1;
				$updata = array();
				$updata['needallot'] = 1;
				$updata['allotstate'] = 0;
				$updata['next_chktime'] = $this->_time+30;
				
				if($nowhour>=22 || $nowhour<9){
					$isaudit = -2; // 无人上班的时间段，直接进第二天的延迟分配池子
					$updata = array(
						'needallot'		=> 0,
						'next_chktime'		=> 0,
					);
				}
			}
			
			if($task['isaudit']!=$isaudit){
				$srvTask->set('isaudit',$isaudit); // 池子标识
				if($srvTask->save() === false){
					throw new Exception('更新待分配标识失败');
				}
			}
			if($updata['needallot']==2){
				$grabData=array(
					'task_id'  => $task['task_id'],
					'type'  => 1,
					'weights'	=> $taskpool['weights'],
					'createtime'  => time(),
				);
				$allotGrabPoolModule = zbj_model_api::get('zbj_model_mk_allotgrabpool');
				$insertResult = $allotGrabPoolModule->insert($grabData);
				if(!$insertResult){
					throw new Exception('任务写入盲抢池失败');
				}
			}
			$updatePoolResult = $allotPoolModule->update($poolCondition,$updata);
			if(!$updatePoolResult){
				throw new Exception('更新池子失败');
			}
			
			$this->_commit('mk');	
			
		}catch(Exception $e){
			$this->_rollBack('mk');
			$this->setError(0,$e->getMessage());
			$srvAllotLog->addTaskAllotLog($task['task_id'],array($e->getMessage()));
			return false;
		}
		switch($isaudit){
			case 1:
				$log = '放弃分配，交由审核系统处理';
				break;
			case -2:
				$log = '需第二天延迟分配';
				break;
			default:
				$log = '已重新放入池子';
				break;
		}
		if($updata['needallot']==2){
			$log='放弃分配，进入盲抢池';
		}
		if($isaudit==1 || $isaudit==-2){
			$srvAllotLog->addTaskAllotLog($task['task_id'],array($log));
		}
        //自动分配审核顾问
        if($isaudit == 1 && $updata['allotstate'] == 2){
            if(zbj_lib_Api::taskVerifyManager($task['task_id']) !== true){
                throw new Exception(zbj_lib_Api::getError());
            }
        }
		
		return true;
	}
	
	/**
	 * 将池子中的需求推到分配系统进行分配
	 * @param	int	$limit
	 * @return bool
	 * @author lidacheng
	 * */
	public function pushPoolTaskToAlloter($limit=30){
		$limit = intval($limit);
		($limit>50||$limit<=0) && $limit = 20;

		$taskpoolModel = $this->model();
		$taskpoolModel->setLimit($limit);
		
		$nowtime = time();
		$condition = array(
			'needallot'		=> 1,
			'allotstate'	=> 0,
		);
		$condition[] = "next_chktime<={$nowtime}";
		$datalist = $taskpoolModel->select($condition,'task_id,type','','order by weights desc,next_chktime asc')->items;
		$datalist = (array)$datalist;
		
		$taskids = array();
		foreach($datalist as $row){
			$tid = intval($row['task_id']);
			$tid>0 && $taskids[] = $tid;
		}
		if(empty($taskids)) return true;
                
		
		// 先全部更新为下次执行时间，防止重复执行
		$upall = array(
			'next_chktime'	=> $nowtime + 80,
		);
                
		#后期当商机id超过订单id的时候需要重写
		$result = $taskpoolModel->update('task_id in('.implode(',',$taskids).')',$upall);
		if($result === false){
				return false;
		}
		
		$updata = array('allotstate' => 1); // 先标识为成功，当分配失败后会标识成0
		foreach($datalist as $value){
			
			try{
				$this->_beginTransaction('mk');
				
				if($taskpoolModel->update($value,$updata) === false){
					throw new Exception('推送需求到分配系统失败');
				}
				if($value['type']==1){
					if(zbj_lib_Api::taskNeedAllotManager($value['task_id'],1) !== true){
						throw new Exception(zbj_lib_Api::getError());
					}
				}
				else if($value['type']==2){
					if(zbj_lib_Api::bschanceNeedAllotManager($value['task_id'],1) !== true){
						throw new Exception(zbj_lib_Api::getError());
					}
				}
			
				$this->_commit('mk');	
			}catch(Exception $e){
				$this->_rollBack('mk');
			}
		}
		return true;
	}

}
